## 本质

计算机：

- 代码执行器
- 数据
- 代码

超级简化为这三个部分。

一般来说，在最简单的情况下，代码的书写顺序就是执行顺序，代码执行器拿到代码后就是从头到尾一步一步执行代码。代码在执行器中被执行时会不断修改数据，数据按照代码的顺序被修改。代码在执行器中执行的实现逻辑在执行器中。



这是底层机制。但是这个机制可能会引发一些问题：

- 某一个代码执行的时间太长了，导致其他代码一直不执行。这并不一定是不好的，只不过可能会因为其他的需要儿被定义为问题。比如：浏览器渲染主线程会执行 JavaScript 代码和页面的绘制。
- 修改数据可能会出现问题。一个完整的代码 最理想的情况是全部都按照预期执行完成，修改完数据，返回好结果。但是代码执行过程中修改数据是可能会出现错误的，那么之前修改的数据该如何呢？比如：最经典的购买商品扣钱案例。扣钱成功但是商品的数量不够导致发生错误，代码停止执行，但钱却是实打实得扣除了。又比如：数据的脏读。
- 当引入多个代码执行器时，我们需要并发执行代码时，又会导致数据读取和修改出现问题，同时代码的书写顺序并不一定时执行器执行顺序了，增加心智负担，同时如何处理并发也又不同的规则，那么需要去学习和了解。



代码执行器：Java 虚拟机，Chrome 浏览器 等等都可以简单理解为代码执行器。执行器最本质就是 CPU 一个核心，执行 加减乘运算，执行 if 运算等等。但是这样不便于我们理解，把一些封装好的更加上层的东西看作执行器。

数据： 保存在 计算机磁盘（PostgreSQL数据库）， 计算机内存（Redis 缓存数据库）， 计算机 CPU L1 L2 L3 缓存中

代码： 外部输入给执行器，一般保存在磁盘中。 Java代码， JavaScript 代码等等



作者注： 在我们做项目中，这三个分类其实算是无处不在。比如 Vue3 框架， 站在 Chrome 浏览器层面， vue3 是代码，不过是一个写好的可以帮助我们开发的一个代码库，我们可以在了解了这个代码库的基础上做开发。 站在 vue3 库的基础上， Vue3 算是执行器，不过是一个偏向概念上的执行器（这句话的意思旨在标明我们开发的代码需要符合 Vue3 的语法规范才可以执行，虽然最终会编译为 H5 C3和 JS 代码，假如某一天 Vue3 的核心逻辑放到了 Chrome 浏览器中， Vue3 就是执行器一部分），vue 文件中的代码会创建数据操作数据......





有了上面的基础，我们可以把一些问题看得比较本质了。



## Vue 的数据绑定

单向绑定：

代码 code1 让执行器 executor1（vue） 在内存 m1 中创建了数据 a 。

代码 code2 让执行器 executor1 监听这个数据有没有被修改，如果修改则将文本中的 1 替换为 ！ 。

code3 让执行器 executor2 监听用户的输入， 输入的文本值会存到 数据b ，数据b的值就是对数据 a 的修改值。

code2 一直在 executor1 中执行，code3 一直在 executor2 中执行。

如果修改数据b则会让数据a一同修改。但是修改数据a，数据b不会改变。

code2 的实现可以是轮询，即每隔一小段时间就去看看数据 b 变没变， code2 也会创建一个数据 pervious 表示之前的值，如果对比值一样就是没变，反之则是改变了。（刨根问底：轮询怎么实现？CPU时钟，CPU每进行一次运算也有接口给开发者用，可以自定义每一次运算之前或者之后的行为）

code2 的实现可以更加优雅，那就是 setter ，数据b 的变没变就是执行器改没改这个数据b，正好执行器可以提供给开发者一个函数用来自定义执行器对数据的修改行为（操作）。对数据的操作也无非增删改查，对已有数据最重要的就是 改和查 。



双向绑定：

......



执行器在打算读取一个数据的值的时候，执行器是知道这是一个读取行为，并且执行器给开发者预留了一个方法来给开发者自定义该数据的修改操作。数据的指针读取操作被替换为了一个函数去执行，函数返回结果是读取的值。

```
// 随意编造一种语法
const b = '';
Object.defineProperty('b',{
	get: ()=>{
		// 做些事情
	}
	set: ()=>{
		// 做些事情。比如修改数据 a
	}
})
```







## 数据库的事务



