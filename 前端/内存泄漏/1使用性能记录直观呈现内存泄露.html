<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>使用性能记录直观呈现内存泄露</title>
</head>

<body>
  每次按下代码中引用的按钮时，系统都会将 1 万个 div 节点附加到文档正文，并将一个包含 100 万个 x 字符的字符串推送到 x 数组。
  请查看时间轴记录
  <p>
    -----------------------------------------------------------------------------------------------------------
  </p>
  现在，我们来分析一下代码与屏幕截图的对比情况。如果您查看节点计数器（绿色图表），就会发现它与代码完全匹配。
  <div>
    1. 节点数量会以离散的步骤增加。您可以假定，节点数量每次增加一次，就是对 grow() 的一次调用。
  </div>
  <div>
    2. JS 堆图（蓝色图表）并不那么简单。根据最佳实践，第一个下降实际上是强制垃圾回收（通过按收集垃圾按钮实现）。
    随着录制过程的进行，您可以看到 JS 堆大小出现峰值。
    这是正常且预期的结果：JavaScript 代码会在每次点击按钮时创建 DOM 节点，并在创建包含 100 万个字符的字符串时执行大量工作。
  </div>
  <div>
    3. 这里的关键是，JS 堆结束时的位置高于开始时的位置（这里的“开始”是指强制垃圾回收后的点）。
    在实际应用中，如果您发现 JS 堆大小或节点大小呈现这种增加趋势，则可能意味着存在内存泄漏。
  </div>
<p>
    ------------------------------------------------------------------------------------------------------------
  </p>
  <div><button id="grow">点我将1 万个 div 节点附加到文档正文，并将一个包含 100 万个 x 字符的字符串推送到 x 数组</button></div>
  <script>
    const x = [];

    function grow() {
      for (let i = 0; i < 10000; i++) {
        document.body.appendChild(document.createElement('div'));
      }
      x.push(new Array(1000000).join('x'));
    }

    document.getElementById('grow').addEventListener('click', grow);
  </script>
</body>

</html>