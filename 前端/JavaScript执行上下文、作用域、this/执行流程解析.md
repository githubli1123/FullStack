## 分析程序执行全过程

- 程序启动，全局执行上下文被创建，压入调用栈
  1. 创建全局上下文的 **词法环境**
     1. 创建 **对象环境记录器** ，它用来定义出现在 **全局上下文** 中的变量和函数的关系（负责处理 `let` 和 `const` 定义的变量）
     
        > ❓什么叫出现在 **全局上下文** 中的变量和函数，包含在一个函数里的函数需要收集吗？
     
     2. 创建 **外部环境引用**，值为 **`null`**
     
  2. 创建全局上下文的 **变量环境**
     1. 创建 **对象环境记录器**，它持有 **变量声明语句** 在执行上下文中创建的绑定关系（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
     2. 创建 **外部环境引用**，值为 **`null`**
     
  3. 确定 `this` 值为全局对象（以浏览器为例，就是 `window` ）
  
- 函数被调用，函数执行上下文被创建，压入调用栈
  1. 创建函数上下文的 **词法环境**
     1. 创建 **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `let` 和 `const` 定义的变量）
     2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
  2. 创建函数上下文的 **变量环境**
     1. 创建 **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
     2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
  3. 确定 `this` 值
  
- 进入函数执行上下文的执行阶段：
  1. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。

## 总结

现在我们来总结一下吧：

首先，JavaScript属于**解释型语言**，JavaScript的执行分为解释和执行两个阶段，这两个阶段所做的事并不一样：

解释阶段：

- 词法分析
- 语法分析
- 作用域规则确定

执行阶段：

- 创建执行上下文
- 执行函数代码
- 垃圾回收

JavaScript解释阶段便会确定作用域规则，因此**作用域在函数定义时就已经确定了**，而不是在函数调用时确定，但是**执行上下文是函数执行之前创建的**。

执行上下文最明显的就是this的指向是执行时确定的，执行时是有执行上下文。

✅📑而`作用域访问的变量是编写代码的结构确定`（这句话非常重要）的。

🌟作用域和执行上下文之间最大的区别是： **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。**同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值**。

最后的最后，简要概况一下`作用域`，`词法环境`，`执行上下文`这三者的概念：

- **作用域**：作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。一个作用域下可能包含若干个执行上下文。
- **词法环境**：指相应代码块内标识符与变量值、函数值之间的关联关系的一种体现。词环境内部包含环境记录器和对外部环境的引用。环境记录器是存储变量和函数声明的实际位置，对外部环境的引用意味着可以访问父级词法环境。
- **执行上下文**：JavaScript代码运行的环境。分为全局执行上下文，函数执行上下文和eval函数执行上下文（前两个较常见）。创建执行上下文时会进行this绑定、创建词法环境和变量环境。



作者：Rockky
链接：https://juejin.cn/post/7043408377661095967
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
